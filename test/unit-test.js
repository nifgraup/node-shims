'use strict';

var expect = require('chai').expect,
    assert = require('assert'),
    shims = require('../');

describe('node shims', function() {
    describe('util', function() {
        it('should inherit', function() {
            var A = function() {};
            var B = function() {
                A.call(this);
            };
            shims.util.inherits(B, A);

            var b = new B();
            expect(b).to.be.instanceof(A);
            expect(b).to.be.instanceof(B);
        });

        it('should be an array', function() {
            expect(shims.util.isArray([])).to.be.true;
            expect(shims.util.isArray(1)).to.be.false;
        });

        it('should be a boolean', function() {
            expect(shims.util.isBoolean(true)).to.be.true;
            expect(shims.util.isBoolean(1)).to.be.false;
        });

        it('should be null', function() {
            expect(shims.util.isNull(null)).to.be.true;
            expect(shims.util.isNull(1)).to.be.false;
        });

        it('should be null or undefined', function() {
            expect(shims.util.isNullOrUndefined(null)).to.be.true;
            expect(shims.util.isNullOrUndefined(undefined)).to.be.true;
            expect(shims.util.isNullOrUndefined(1)).to.be.false;
        });

        it('should be a number', function() {
            expect(shims.util.isNumber(1)).to.be.true;
            expect(shims.util.isNumber('s')).to.be.false;
        });

        it('should be a string', function() {
            expect(shims.util.isString('asd')).to.be.true;
            expect(shims.util.isString(1)).to.be.false;
        });

        it('should be undefined', function() {
            expect(shims.util.isUndefined(undefined)).to.be.true;
            expect(shims.util.isUndefined(1)).to.be.false;
        });

        it('should be an object', function() {
            expect(shims.util.isObject({})).to.be.true;
            expect(shims.util.isObject(1)).to.be.false;
        });

        it('should be a function', function() {
            expect(shims.util.isFunction(function() {})).to.be.true;
            expect(shims.util.isFunction(1)).to.be.false;
        });

        it('should be a primitive', function() {
            expect(shims.util.isPrimitive(1)).to.be.true;
            expect(shims.util.isPrimitive({})).to.be.false;
        });
    });

    describe('stream', function() {
        it('should expose stream api', function() {
            expect(shims.Stream).to.be.ok;
            expect(shims.Stream.Duplex).to.be.ok;
            expect(shims.Stream.Readable).to.be.ok;
            expect(shims.Stream.Writable).to.be.ok;
            expect(shims.Stream.Transform).to.be.ok;
            expect(shims.Stream.PassThrough).to.be.ok;
        });

        // TODO: add real unit tests for stream!
    });

    describe('net', function() {
        // this api is for now available exclusively in chrome...
        it('should expose net api', function() {
            expect(shims.net).to.be.ok;
            expect(shims.net.connect).to.be.ok;
            expect(shims.net.createConnection).to.be.ok;
            expect(shims.net.Socket).to.be.ok;
        });

        // TODO: add real unit tests for net!
    });

    describe('tls', function() {
        // this api is for now available exclusively in chrome...
        it('should expose tls api', function() {
            expect(shims.tls).to.be.ok;
            expect(shims.tls.connect).to.be.ok;
            expect(shims.tls.Socket).to.be.ok;
        });

        // TODO: add real unit tests for tls!
    });

    describe('crypto', function() {
        var B = shims.Buffer.Buffer,
            expected = {};

        // expected values generated by node crypto.
        expected['sha1-hash-binary'] = new B('qvTGHdzF6KLavt4PO0gs2a6pQ00=', 'base64').toString('binary');
        expected['sha1-hash-hex'] = 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d';
        expected['sha1-hash-base64'] = 'qvTGHdzF6KLavt4PO0gs2a6pQ00=';
        expected['sha256-hash-binary'] = new B('LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=', 'base64').toString('binary');
        expected['sha256-hash-hex'] = '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824';
        expected['sha256-hash-base64'] = 'LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=';
        expected['md5-hash-binary'] = new B('XUFAKrxLKna5cZ2REBfFkg==', 'base64').toString('binary');
        expected['md5-hash-hex'] = '5d41402abc4b2a76b9719d911017c592';
        expected['md5-hash-base64'] = 'XUFAKrxLKna5cZ2REBfFkg==';
        expected['sha1-hmac-binary'] = new B('URIFXAX5RPhXVe/FzYlw4ZTp9Fs=', 'base64').toString('binary');
        expected['sha1-hmac-hex'] = '5112055c05f944f85755efc5cd8970e194e9f45b';
        expected['sha1-hmac-base64'] = 'URIFXAX5RPhXVe/FzYlw4ZTp9Fs=';
        expected['sha256-hmac-binary'] = new B('iKqz7ejTrflNJquQ07r9SiCDBww7zOnAFO4EpEOEfAs=', 'base64').toString('binary');
        expected['sha256-hmac-hex'] = '88aab3ede8d3adf94d26ab90d3bafd4a2083070c3bcce9c014ee04a443847c0b';
        expected['sha256-hmac-base64'] = 'iKqz7ejTrflNJquQ07r9SiCDBww7zOnAFO4EpEOEfAs=';
        expected['md5-hmac-binary'] = new B('ut5jhjxh7QsxZYBuzWrO/A==', 'base64').toString('binary');
        expected['md5-hmac-hex'] = 'bade63863c61ed0b3165806ecd6acefc';
        expected['md5-hmac-base64'] = 'ut5jhjxh7QsxZYBuzWrO/A==';
        expected['md5-with-binary'] = '27549c8ff29ca52f7957f89c328dbb6d';
        expected['sha1-with-binary'] = '4fa10dda29053b237b5d9703151c852c61e6d8d7';
        expected['sha256-with-binary'] = '424ff84246aabc1560a2881b9664108dfe26784c762d930c4ff396c085f4183b';
        expected['md5-empty-string'] = 'd41d8cd98f00b204e9800998ecf8427e';
        expected['sha1-empty-string'] = 'da39a3ee5e6b4b0d3255bfef95601890afd80709';
        expected['sha256-empty-string'] = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';

        it('sha1 hash using binary', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha1-hash-binary'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using binary', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha1-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('sha1 hash using hex', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha1-hash-hex'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using hex', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha1-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('sha1 hash using base64', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha1-hash-base64'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using base64', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha1-hmac-base64'];
            assert.equal(actual, exp);
        });
        it('sha1 with empty string', function() {
            var actual = shims.crypto.createHash('sha1').update('', 'utf-8').digest('hex');
            var exp = expected['sha1-empty-string'];
            assert.equal(actual, exp);
        });

        it('sha1 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('sha1').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('sha1').update(seed).digest('hex');
            var exp = expected['sha1-with-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using binary', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha256-hash-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using binary', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha256-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using hex', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha256-hash-hex'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using hex', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha256-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using base64', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha256-hash-base64'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using base64', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha256-hmac-base64'];
            assert.equal(actual, exp);
        });

        it('sha256 with empty string', function() {
            var actual = shims.crypto.createHash('sha256').update('', 'utf-8').digest('hex');
            var exp = expected['sha256-empty-string'];
            assert.equal(actual, exp);
        });

        it('sha256 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('sha256').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('sha256').update(seed).digest('hex');
            var exp = expected['sha256-with-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hash using binary', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('binary');
            var exp = expected['md5-hash-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using binary', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['md5-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hash using hex', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('hex');
            var exp = expected['md5-hash-hex'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using hex', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['md5-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('md5 hash using base64', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('base64');
            var exp = expected['md5-hash-base64'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using base64', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['md5-hmac-base64'];
            assert.equal(actual, exp);
        });

        it('md5 with empty string', function() {
            var actual = shims.crypto.createHash('md5').update('', 'utf-8').digest('hex');
            var exp = expected['md5-empty-string'];
            assert.equal(actual, exp);
        });

        it('md5 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('md5').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('md5').update(seed).digest('hex');
            var exp = expected['md5-with-binary'];
            assert.equal(actual, exp);
        });
    });

    describe('buffer', function() {
        var B = shims.Buffer.Buffer;

        it('utf8 buffer to base64', function() {
            assert.equal(new B('Ձאab', 'utf8').toString('base64'), '1YHXkGFi');
        });

        it('utf8 buffer to hex', function() {
            assert.equal(new B('Ձאab', 'utf8').toString('hex'), 'd581d7906162');
        });

        it('utf8 to utf8', function() {
            assert.equal(new B('öäüõÖÄÜÕ', 'utf8').toString('utf8'), 'öäüõÖÄÜÕ');
        });

        it('ascii buffer to base64', function() {
            assert.equal(new B('123456!@#$%^', 'ascii').toString('base64'), 'MTIzNDU2IUAjJCVe');
        });

        it('ascii buffer to hex', function() {
            assert.equal(new B('123456!@#$%^', 'ascii').toString('hex'), '31323334353621402324255e');
        });

        it('base64 buffer to utf8', function() {
            assert.equal(new B('1YHXkGFi', 'base64').toString('utf8'), 'Ձאab');
        });

        it('hex buffer to utf8', function() {
            assert.equal(new B('d581d7906162', 'hex').toString('utf8'), 'Ձאab');
        });

        it('base64 buffer to ascii', function() {
            assert.equal(new B('MTIzNDU2IUAjJCVe', 'base64').toString('ascii'), '123456!@#$%^');
        });

        it('hex buffer to ascii', function() {
            assert.equal(new B('31323334353621402324255e', 'hex').toString('ascii'), '123456!@#$%^');
        });

        // it('utf8 to ascii', function() {
        //     assert.equal(new B('öäüõÖÄÜÕ', 'utf8').toString('ascii'), 'C6C$C<C5C\u0016C\u0004C\u001cC\u0015');
        // });

        it('base64 buffer to binary', function() {
            assert.equal(new B('MTIzNDU2IUAjJCVe', 'base64').toString('binary'), '123456!@#$%^');
        });

        it('hex buffer to binary', function() {
            assert.equal(new B('31323334353621402324255e', 'hex').toString('binary'), '123456!@#$%^');
        });

        it('utf8 to binary', function() {
            assert.equal(new B('asdž', 'utf8').toString('binary'), 'asdÅ¾');
        });

        it('hex of write{Uint,Int}{8,16,32}{LE,BE}', function() {
            var hex = [
                '03', '0300', '0003', '03000000', '00000003',
                'fd', 'fdff', 'fffd', 'fdffffff', 'fffffffd'
            ];
            var reads = [3, 3, 3, 3, 3, -3, -3, -3, -3, -3];
            ['UInt', 'Int'].forEach(function(x) {
                [8, 16, 32].forEach(function(y) {
                    var endianesses = (y === 8) ? [''] : ['LE', 'BE'];
                    endianesses.forEach(function(z) {
                        var v1 = new B(y / 8);
                        var writefn = 'write' + x + y + z;
                        var val = (x === 'Int') ? -3 : 3;
                        v1[writefn](val, 0);
                        assert.equal(
                            v1.toString('hex'),
                            hex.shift()
                        );
                        var readfn = 'read' + x + y + z;
                        assert.equal(
                            v1[readfn](0),
                            reads.shift()
                        );
                    });
                });
            });
        });

        it('hex of write{Uint,Int}{8,16,32}{LE,BE} with overflow', function() {
            var hex = [
                '', '03', '00', '030000', '000000',
                '', 'fd', 'ff', 'fdffff', 'ffffff'
            ];
            var reads = [
                undefined, 3, 0, 3, 0,
                undefined, 253, -256, 16777213, -256
            ];
            ['UInt', 'Int'].forEach(function(x) {
                [8, 16, 32].forEach(function(y) {
                    var endianesses = (y === 8) ? [''] : ['LE', 'BE'];
                    endianesses.forEach(function(z) {
                        var v1 = new B(y / 8 - 1);
                        var next = new B(4);
                        next.writeUInt32BE(0, 0);
                        var writefn = 'write' + x + y + z;
                        var val = (x === 'Int') ? -3 : 3;
                        v1[writefn](val, 0, true);
                        assert.equal(
                            v1.toString('hex'),
                            hex.shift()
                        );
                        // check that nothing leaked to next buffer.
                        assert.equal(next.readUInt32BE(0), 0);
                        // check that no bytes are read from next buffer.
                        next.writeInt32BE(~0, 0);
                        var readfn = 'read' + x + y + z;
                        assert.equal(
                            v1[readfn](0, true),
                            reads.shift()
                        );
                    });
                });
            });
        });

        it('concat() a varying number of buffers', function() {
            var zero = [];
            var one = [new B('asdf')];
            var long = [];
            for (var i = 0; i < 10; i++) {
                long.push(new B('asdf'));
            }

            var flatZero = B.concat(zero);
            var flatOne = B.concat(one);
            var flatLong = B.concat(long);
            var flatLongLen = B.concat(long, 40);

            assert.equal(flatZero.length, 0);
            assert.equal(flatOne.toString(), 'asdf');
            assert.equal(flatOne, one[0]);
            assert.equal(flatLong.toString(), (new Array(10 + 1).join('asdf')));
            assert.equal(flatLongLen.toString(), (new Array(10 + 1).join('asdf')));
        });

        it('buffer from buffer', function() {
            var b1 = new B('asdf');
            var b2 = new B(b1);
            assert.equal(b1.toString('hex'), b2.toString('hex'));
        });

        it('fill', function() {
            var b = new B(10);
            b.fill(2);
            assert.equal(b.toString('hex'), '02020202020202020202');
        });

        it('copy() empty buffer with sourceEnd=0', function() {
            var source = new B([42]);
            var destination = new B([43]);
            source.copy(destination, 0, 0, 0);
            assert.equal(destination.readUInt8(0), 43);
        });

        it('base64 ignore whitespace', function() {
            var text = '\n   YW9ldQ==  ';
            var buf = new B(text, 'base64');
            assert.equal(buf.toString(), 'aoeu');
        });

        it('buffer.slice sets indexes', function() {
            assert.equal((new B('hallo')).slice(0, 5).toString(), 'hallo');
        });

        it('buffer.slice out of range', function() {
            assert.equal((new B('hallo')).slice(0, 10).toString(), 'hallo');
            assert.equal((new B('hallo')).slice(10, 2).toString(), '');
        });

        it('base64 strings without padding', function() {
            assert.equal((new B('YW9ldQ', 'base64').toString()), 'aoeu');
        });

        it('indexes from a string', function() {
            var buf = new B('abc');
            assert.equal(buf[0], 97);
            assert.equal(buf[1], 98);
            assert.equal(buf[2], 99);
        });

        it('indexes from an array', function() {
            var buf = new B([97, 98, 99]);
            assert.equal(buf[0], 97);
            assert.equal(buf[1], 98);
            assert.equal(buf[2], 99);
        });

        it('set then modify indexes from an array', function() {
            var buf = new B([97, 98, 99]);
            assert.equal(buf[2], 99);
            assert.equal(buf.toString(), 'abc');

            buf[2] += 10;
            assert.equal(buf[2], 109);
            assert.equal(buf.toString(), 'abm');
        });

        it('Buffer.isEncoding', function() {
            assert.equal(B.isEncoding('HEX'), true);
            assert.equal(B.isEncoding('hex'), true);
            assert.equal(B.isEncoding('bad'), false);
        });

    });

    describe('querystring', function() {

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var qs = shims.querystring;
        it('generate querystring', function() {
            /* jshint -W001 */
            /*jshint -W053 */
            var qsTestCases = [
                ['foo=918854443121279438895193', 'foo=918854443121279438895193', {
                    'foo': '918854443121279438895193'
                }],
                ['foo=bar', 'foo=bar', {
                    'foo': 'bar'
                }],
                ['foo=bar&foo=quux', 'foo=bar&foo=quux', {
                    'foo': ['bar', 'quux']
                }],
                ['foo=1&bar=2', 'foo=1&bar=2', {
                    'foo': '1',
                    'bar': '2'
                }],
                ['my+weird+field=q1%212%22%27w%245%267%2Fz8%29%3F', 'my%20weird%20field=q1!2%22\'w%245%267%2Fz8)%3F', {
                    'my weird field': 'q1!2"\'w$5&7/z8)?'
                }],
                ['foo%3Dbaz=bar', 'foo%3Dbaz=bar', {
                    'foo=baz': 'bar'
                }],
                ['foo=baz=bar', 'foo=baz%3Dbar', {
                    'foo': 'baz=bar'
                }],
                ['str=foo&arr=1&arr=2&arr=3&somenull=&undef=', 'str=foo&arr=1&arr=2&arr=3&somenull=&undef=', {
                    'str': 'foo',
                    'arr': ['1', '2', '3'],
                    'somenull': '',
                    'undef': ''
                }],
                [' foo = bar ', '%20foo%20=%20bar%20', {
                    ' foo ': ' bar '
                }],
                ['foo=%zx', 'foo=%25zx', {
                    'foo': '%zx'
                }],
                ['foo=%EF%BF%BD', 'foo=%EF%BF%BD', {
                    'foo': '\ufffd'
                }],
                // See: https://github.com/joyent/node/issues/1707
                ['hasOwnProperty=x&toString=foo&valueOf=bar&__defineGetter__=baz', 'hasOwnProperty=x&toString=foo&valueOf=bar&__defineGetter__=baz', {
                    hasOwnProperty: 'x',
                    toString: 'foo',
                    valueOf: 'bar',
                    __defineGetter__: 'baz'
                }],
                // See: https://github.com/joyent/node/issues/3058
                ['foo&bar=baz', 'foo=&bar=baz', {
                    foo: '',
                    bar: 'baz'
                }]
            ];

            // [ wonkyQS, canonicalQS, obj ]
            var qsColonTestCases = [
                ['foo:bar', 'foo:bar', {
                    'foo': 'bar'
                }],
                ['foo:bar;foo:quux', 'foo:bar;foo:quux', {
                    'foo': ['bar', 'quux']
                }],
                ['foo:1&bar:2;baz:quux', 'foo:1%26bar%3A2;baz:quux', {
                    'foo': '1&bar:2',
                    'baz': 'quux'
                }],
                ['foo%3Abaz:bar', 'foo%3Abaz:bar', {
                    'foo:baz': 'bar'
                }],
                ['foo:baz:bar', 'foo:baz%3Abar', {
                    'foo': 'baz:bar'
                }]
            ];

            // [wonkyObj, qs, canonicalObj]
            var extendedFunction = function() {};
            extendedFunction.prototype = {
                a: 'b'
            };
            var qsWeirdObjects = [
                [{
                    regexp: /./g
                }, 'regexp=', {
                    'regexp': ''
                }],
                [{
                    regexp: new RegExp('.', 'g')
                }, 'regexp=', {
                    'regexp': ''
                }],
                [{
                    fn: function() {}
                }, 'fn=', {
                    'fn': ''
                }],
                [{
                    fn: new Function('')
                }, 'fn=', {
                    'fn': ''
                }],
                [{
                    math: Math
                }, 'math=', {
                    'math': ''
                }],
                [{
                    e: extendedFunction
                }, 'e=', {
                    'e': ''
                }],
                [{
                    d: new Date()
                }, 'd=', {
                    'd': ''
                }],
                [{
                    d: Date
                }, 'd=', {
                    'd': ''
                }],
                [{
                    f: new Boolean(false),
                    t: new Boolean(true)
                }, 'f=&t=', {
                    'f': '',
                    't': ''
                }],
                [{
                    f: false,
                    t: true
                }, 'f=false&t=true', {
                    'f': 'false',
                    't': 'true'
                }],
                [{
                    n: null
                }, 'n=', {
                    'n': ''
                }],
                [{
                    nan: NaN
                }, 'nan=', {
                    'nan': ''
                }],
                [{
                    inf: Infinity
                }, 'inf=', {
                    'inf': ''
                }]
            ];

            var vm = require('vm');
            var foreignObject = vm.runInNewContext('({"foo": ["bar", "baz"]})');

            var qsNoMungeTestCases = [
                ['', {}],
                ['foo=bar&foo=baz', {
                    'foo': ['bar', 'baz']
                }],
                ['foo=bar&foo=baz', foreignObject],
                ['blah=burp', {
                    'blah': 'burp'
                }],
                ['gragh=1&gragh=3&goo=2', {
                    'gragh': ['1', '3'],
                    'goo': '2'
                }],
                ['frappucino=muffin&goat%5B%5D=scone&pond=moose', {
                    'frappucino': 'muffin',
                    'goat[]': 'scone',
                    'pond': 'moose'
                }],
                ['trololol=yes&lololo=no', {
                    'trololol': 'yes',
                    'lololo': 'no'
                }]
            ];

            assert.strictEqual('918854443121279438895193',
                qs.parse('id=918854443121279438895193').id);

            // test that the canonical qs is parsed properly.
            qsTestCases.forEach(function(testCase) {
                assert.deepEqual(testCase[2], qs.parse(testCase[0]));
            });

            // test that the colon test cases can do the same
            qsColonTestCases.forEach(function(testCase) {
                assert.deepEqual(testCase[2], qs.parse(testCase[0], ';', ':'));
            });

            // test the weird objects, that they get parsed properly
            qsWeirdObjects.forEach(function(testCase) {
                assert.deepEqual(testCase[2], qs.parse(testCase[1]));
            });

            qsNoMungeTestCases.forEach(function(testCase) {
                assert.deepEqual(testCase[0], qs.stringify(testCase[1], '&', '=', false));
            });

            // test the nested qs-in-qs case
            (function() {
                var f = qs.parse('a=b&q=x%3Dy%26y%3Dz');
                f.q = qs.parse(f.q);
                assert.deepEqual(f, {
                    a: 'b',
                    q: {
                        x: 'y',
                        y: 'z'
                    }
                });
            })();

            // nested in colon
            (function() {
                var f = qs.parse('a:b;q:x%3Ay%3By%3Az', ';', ':');
                f.q = qs.parse(f.q, ';', ':');
                assert.deepEqual(f, {
                    a: 'b',
                    q: {
                        x: 'y',
                        y: 'z'
                    }
                });
            })();

            // now test stringifying

            // basic
            qsTestCases.forEach(function(testCase) {
                assert.equal(testCase[1], qs.stringify(testCase[2]));
            });

            qsColonTestCases.forEach(function(testCase) {
                assert.equal(testCase[1], qs.stringify(testCase[2], ';', ':'));
            });

            qsWeirdObjects.forEach(function(testCase) {
                assert.equal(testCase[1], qs.stringify(testCase[0]));
            });

            // nested
            var f = qs.stringify({
                a: 'b',
                q: qs.stringify({
                    x: 'y',
                    y: 'z'
                })
            });
            assert.equal(f, 'a=b&q=x%3Dy%26y%3Dz');

            assert.doesNotThrow(function() {
                qs.parse(undefined);
            });

            // nested in colon
            f = qs.stringify({
                a: 'b',
                q: qs.stringify({
                    x: 'y',
                    y: 'z'
                }, ';', ':')
            }, ';', ':');
            assert.equal(f, 'a:b;q:x%3Ay%3By%3Az');


            assert.deepEqual({}, qs.parse());


            // Test limiting
            assert.equal(
                Object.keys(qs.parse('a=1&b=1&c=1', null, null, {
                    maxKeys: 1
                })).length,
                1);

            // Test removing limit

            function testUnlimitedKeys() {
                var query = {},
                    url;

                for (var i = 0; i < 2000; i++) {
                    query[i] = i;
                }

                url = qs.stringify(query);

                assert.equal(
                    Object.keys(qs.parse(url, null, null, {
                        maxKeys: 0
                    })).length,
                    2000);
            }
            testUnlimitedKeys();


            var b = qs.unescapeBuffer('%d3%f2Ug%1f6v%24%5e%98%cb' +
                '%0d%ac%a2%2f%9d%eb%d8%a2%e6');
            // <Buffer d3 f2 55 67 1f 36 76 24 5e 98 cb 0d ac a2 2f 9d eb d8 a2 e6>
            assert.equal(0xd3, b[0]);
            assert.equal(0xf2, b[1]);
            assert.equal(0x55, b[2]);
            assert.equal(0x67, b[3]);
            assert.equal(0x1f, b[4]);
            assert.equal(0x36, b[5]);
            assert.equal(0x76, b[6]);
            assert.equal(0x24, b[7]);
            assert.equal(0x5e, b[8]);
            assert.equal(0x98, b[9]);
            assert.equal(0xcb, b[10]);
            assert.equal(0x0d, b[11]);
            assert.equal(0xac, b[12]);
            assert.equal(0xa2, b[13]);
            assert.equal(0x2f, b[14]);
            assert.equal(0x9d, b[15]);
            assert.equal(0xeb, b[16]);
            assert.equal(0xd8, b[17]);
            assert.equal(0xa2, b[18]);
            assert.equal(0xe6, b[19]);
        });
    });
});