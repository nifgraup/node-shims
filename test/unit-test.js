'use strict';

var expect = require('chai').expect,
    assert = require('assert'),
    shims = require('../');

describe('node shims', function() {
    describe('util', function() {
        it('should inherit', function() {
            var A = function() {};
            var B = function() {
                A.call(this);
            };
            shims.util.inherits(B, A);

            var b = new B();
            expect(b).to.be.instanceof(A);
            expect(b).to.be.instanceof(B);
        });

        it('should be an array', function() {
            expect(shims.util.isArray([])).to.be.true;
            expect(shims.util.isArray(1)).to.be.false;
        });

        it('should be a boolean', function() {
            expect(shims.util.isBoolean(true)).to.be.true;
            expect(shims.util.isBoolean(1)).to.be.false;
        });

        it('should be null', function() {
            expect(shims.util.isNull(null)).to.be.true;
            expect(shims.util.isNull(1)).to.be.false;
        });

        it('should be null or undefined', function() {
            expect(shims.util.isNullOrUndefined(null)).to.be.true;
            expect(shims.util.isNullOrUndefined(undefined)).to.be.true;
            expect(shims.util.isNullOrUndefined(1)).to.be.false;
        });

        it('should be a number', function() {
            expect(shims.util.isNumber(1)).to.be.true;
            expect(shims.util.isNumber('s')).to.be.false;
        });

        it('should be a string', function() {
            expect(shims.util.isString('asd')).to.be.true;
            expect(shims.util.isString(1)).to.be.false;
        });

        it('should be undefined', function() {
            expect(shims.util.isUndefined(undefined)).to.be.true;
            expect(shims.util.isUndefined(1)).to.be.false;
        });

        it('should be an object', function() {
            expect(shims.util.isObject({})).to.be.true;
            expect(shims.util.isObject(1)).to.be.false;
        });

        it('should be a function', function() {
            expect(shims.util.isFunction(function() {})).to.be.true;
            expect(shims.util.isFunction(1)).to.be.false;
        });

        it('should be a primitive', function() {
            expect(shims.util.isPrimitive(1)).to.be.true;
            expect(shims.util.isPrimitive({})).to.be.false;
        });
    });

    describe('stream', function() {
        it('should expose stream api', function() {
            expect(shims.Stream).to.be.ok;
            expect(shims.Stream.Duplex).to.be.ok;
            expect(shims.Stream.Readable).to.be.ok;
            expect(shims.Stream.Writable).to.be.ok;
            expect(shims.Stream.Transform).to.be.ok;
            expect(shims.Stream.PassThrough).to.be.ok;
        });

        // TODO: add real unit tests for stream!
    });

    describe('net', function() {
        // this api is for now available exclusively in chrome...
        it('should expose net api', function() {
            expect(shims.net).to.be.ok;
            expect(shims.net.connect).to.be.ok;
            expect(shims.net.createConnection).to.be.ok;
            expect(shims.net.Socket).to.be.ok;
        });

        // TODO: add real unit tests for net!
    });

    describe('tls', function() {
        // this api is for now available exclusively in chrome...
        it('should expose tls api', function() {
            expect(shims.tls).to.be.ok;
            expect(shims.tls.connect).to.be.ok;
            expect(shims.tls.Socket).to.be.ok;
        });

        // TODO: add real unit tests for tls!
    });

    describe('crypto', function() {
        var B = shims.Buffer.Buffer,
            expected = {};

        // expected values generated by node crypto.
        expected['sha1-hash-binary'] = new B('qvTGHdzF6KLavt4PO0gs2a6pQ00=', 'base64').toString('binary');
        expected['sha1-hash-hex'] = 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d';
        expected['sha1-hash-base64'] = 'qvTGHdzF6KLavt4PO0gs2a6pQ00=';
        expected['sha256-hash-binary'] = new B('LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=', 'base64').toString('binary');
        expected['sha256-hash-hex'] = '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824';
        expected['sha256-hash-base64'] = 'LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=';
        expected['md5-hash-binary'] = new B('XUFAKrxLKna5cZ2REBfFkg==', 'base64').toString('binary');
        expected['md5-hash-hex'] = '5d41402abc4b2a76b9719d911017c592';
        expected['md5-hash-base64'] = 'XUFAKrxLKna5cZ2REBfFkg==';
        expected['sha1-hmac-binary'] = new B('URIFXAX5RPhXVe/FzYlw4ZTp9Fs=', 'base64').toString('binary');
        expected['sha1-hmac-hex'] = '5112055c05f944f85755efc5cd8970e194e9f45b';
        expected['sha1-hmac-base64'] = 'URIFXAX5RPhXVe/FzYlw4ZTp9Fs=';
        expected['sha256-hmac-binary'] = new B('iKqz7ejTrflNJquQ07r9SiCDBww7zOnAFO4EpEOEfAs=', 'base64').toString('binary');
        expected['sha256-hmac-hex'] = '88aab3ede8d3adf94d26ab90d3bafd4a2083070c3bcce9c014ee04a443847c0b';
        expected['sha256-hmac-base64'] = 'iKqz7ejTrflNJquQ07r9SiCDBww7zOnAFO4EpEOEfAs=';
        expected['md5-hmac-binary'] = new B('ut5jhjxh7QsxZYBuzWrO/A==', 'base64').toString('binary');
        expected['md5-hmac-hex'] = 'bade63863c61ed0b3165806ecd6acefc';
        expected['md5-hmac-base64'] = 'ut5jhjxh7QsxZYBuzWrO/A==';
        expected['md5-with-binary'] = '27549c8ff29ca52f7957f89c328dbb6d';
        expected['sha1-with-binary'] = '4fa10dda29053b237b5d9703151c852c61e6d8d7';
        expected['sha256-with-binary'] = '424ff84246aabc1560a2881b9664108dfe26784c762d930c4ff396c085f4183b';
        expected['md5-empty-string'] = 'd41d8cd98f00b204e9800998ecf8427e';
        expected['sha1-empty-string'] = 'da39a3ee5e6b4b0d3255bfef95601890afd80709';
        expected['sha256-empty-string'] = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';

        it('sha1 hash using binary', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha1-hash-binary'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using binary', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha1-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('sha1 hash using hex', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha1-hash-hex'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using hex', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha1-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('sha1 hash using base64', function() {
            var actual = shims.crypto.createHash('sha1').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha1-hash-base64'];
            assert.equal(actual, exp);
        });

        it('sha1 hmac using base64', function() {
            var actual = shims.crypto.createHmac('sha1', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha1-hmac-base64'];
            assert.equal(actual, exp);
        });
        it('sha1 with empty string', function() {
            var actual = shims.crypto.createHash('sha1').update('', 'utf-8').digest('hex');
            var exp = expected['sha1-empty-string'];
            assert.equal(actual, exp);
        });

        it('sha1 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('sha1').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('sha1').update(seed).digest('hex');
            var exp = expected['sha1-with-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using binary', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha256-hash-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using binary', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['sha256-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using hex', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha256-hash-hex'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using hex', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['sha256-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('sha256 hash using base64', function() {
            var actual = shims.crypto.createHash('sha256').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha256-hash-base64'];
            assert.equal(actual, exp);
        });

        it('sha256 hmac using base64', function() {
            var actual = shims.crypto.createHmac('sha256', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['sha256-hmac-base64'];
            assert.equal(actual, exp);
        });

        it('sha256 with empty string', function() {
            var actual = shims.crypto.createHash('sha256').update('', 'utf-8').digest('hex');
            var exp = expected['sha256-empty-string'];
            assert.equal(actual, exp);
        });

        it('sha256 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('sha256').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('sha256').update(seed).digest('hex');
            var exp = expected['sha256-with-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hash using binary', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('binary');
            var exp = expected['md5-hash-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using binary', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('binary');
            var exp = expected['md5-hmac-binary'];
            assert.equal(actual, exp);
        });

        it('md5 hash using hex', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('hex');
            var exp = expected['md5-hash-hex'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using hex', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('hex');
            var exp = expected['md5-hmac-hex'];
            assert.equal(actual, exp);
        });

        it('md5 hash using base64', function() {
            var actual = shims.crypto.createHash('md5').update('hello', 'utf-8').digest('base64');
            var exp = expected['md5-hash-base64'];
            assert.equal(actual, exp);
        });

        it('md5 hmac using base64', function() {
            var actual = shims.crypto.createHmac('md5', 'secret').update('hello', 'utf-8').digest('base64');
            var exp = expected['md5-hmac-base64'];
            assert.equal(actual, exp);
        });

        it('md5 with empty string', function() {
            var actual = shims.crypto.createHash('md5').update('', 'utf-8').digest('hex');
            var exp = expected['md5-empty-string'];
            assert.equal(actual, exp);
        });

        it('md5 with raw binary', function() {
            var seed = 'hello';
            for (var i = 0; i < 1000; i++) {
                seed = shims.crypto.createHash('md5').update(seed).digest('binary');
            }
            var actual = shims.crypto.createHash('md5').update(seed).digest('hex');
            var exp = expected['md5-with-binary'];
            assert.equal(actual, exp);
        });
    });

    describe('buffer', function() {
        var B = shims.Buffer.Buffer;

        it('utf8 buffer to base64', function() {
            assert.equal(new B('Ձאab', 'utf8').toString('base64'), '1YHXkGFi');
        });

        it('utf8 buffer to hex', function() {
            assert.equal(new B('Ձאab', 'utf8').toString('hex'), 'd581d7906162');
        });

        it('utf8 to utf8', function() {
            assert.equal(new B('öäüõÖÄÜÕ', 'utf8').toString('utf8'), 'öäüõÖÄÜÕ');
        });

        it('ascii buffer to base64', function() {
            assert.equal(new B('123456!@#$%^', 'ascii').toString('base64'), 'MTIzNDU2IUAjJCVe');
        });

        it('ascii buffer to hex', function() {
            assert.equal(new B('123456!@#$%^', 'ascii').toString('hex'), '31323334353621402324255e');
        });

        it('base64 buffer to utf8', function() {
            assert.equal(new B('1YHXkGFi', 'base64').toString('utf8'), 'Ձאab');
        });

        it('hex buffer to utf8', function() {
            assert.equal(new B('d581d7906162', 'hex').toString('utf8'), 'Ձאab');
        });

        it('base64 buffer to ascii', function() {
            assert.equal(new B('MTIzNDU2IUAjJCVe', 'base64').toString('ascii'), '123456!@#$%^');
        });

        it('hex buffer to ascii', function() {
            assert.equal(new B('31323334353621402324255e', 'hex').toString('ascii'), '123456!@#$%^');
        });

        // it('utf8 to ascii', function() {
        //     assert.equal(new B('öäüõÖÄÜÕ', 'utf8').toString('ascii'), 'C6C$C<C5C\u0016C\u0004C\u001cC\u0015');
        // });

        it('base64 buffer to binary', function() {
            assert.equal(new B('MTIzNDU2IUAjJCVe', 'base64').toString('binary'), '123456!@#$%^');
        });

        it('hex buffer to binary', function() {
            assert.equal(new B('31323334353621402324255e', 'hex').toString('binary'), '123456!@#$%^');
        });

        it('utf8 to binary', function() {
            assert.equal(new B('asdž', 'utf8').toString('binary'), 'asdÅ¾');
        });

        it('hex of write{Uint,Int}{8,16,32}{LE,BE}', function() {
            var hex = [
                '03', '0300', '0003', '03000000', '00000003',
                'fd', 'fdff', 'fffd', 'fdffffff', 'fffffffd'
            ];
            var reads = [3, 3, 3, 3, 3, -3, -3, -3, -3, -3];
            ['UInt', 'Int'].forEach(function(x) {
                [8, 16, 32].forEach(function(y) {
                    var endianesses = (y === 8) ? [''] : ['LE', 'BE'];
                    endianesses.forEach(function(z) {
                        var v1 = new B(y / 8);
                        var writefn = 'write' + x + y + z;
                        var val = (x === 'Int') ? -3 : 3;
                        v1[writefn](val, 0);
                        assert.equal(
                            v1.toString('hex'),
                            hex.shift()
                        );
                        var readfn = 'read' + x + y + z;
                        assert.equal(
                            v1[readfn](0),
                            reads.shift()
                        );
                    });
                });
            });
        });

        it('hex of write{Uint,Int}{8,16,32}{LE,BE} with overflow', function() {
            var hex = [
                '', '03', '00', '030000', '000000',
                '', 'fd', 'ff', 'fdffff', 'ffffff'
            ];
            var reads = [
                undefined, 3, 0, 3, 0,
                undefined, 253, -256, 16777213, -256
            ];
            ['UInt', 'Int'].forEach(function(x) {
                [8, 16, 32].forEach(function(y) {
                    var endianesses = (y === 8) ? [''] : ['LE', 'BE'];
                    endianesses.forEach(function(z) {
                        var v1 = new B(y / 8 - 1);
                        var next = new B(4);
                        next.writeUInt32BE(0, 0);
                        var writefn = 'write' + x + y + z;
                        var val = (x === 'Int') ? -3 : 3;
                        v1[writefn](val, 0, true);
                        assert.equal(
                            v1.toString('hex'),
                            hex.shift()
                        );
                        // check that nothing leaked to next buffer.
                        assert.equal(next.readUInt32BE(0), 0);
                        // check that no bytes are read from next buffer.
                        next.writeInt32BE(~0, 0);
                        var readfn = 'read' + x + y + z;
                        assert.equal(
                            v1[readfn](0, true),
                            reads.shift()
                        );
                    });
                });
            });
        });

        it('concat() a varying number of buffers', function() {
            var zero = [];
            var one = [new B('asdf')];
            var long = [];
            for (var i = 0; i < 10; i++) {
                long.push(new B('asdf'));
            }

            var flatZero = B.concat(zero);
            var flatOne = B.concat(one);
            var flatLong = B.concat(long);
            var flatLongLen = B.concat(long, 40);

            assert.equal(flatZero.length, 0);
            assert.equal(flatOne.toString(), 'asdf');
            assert.equal(flatOne, one[0]);
            assert.equal(flatLong.toString(), (new Array(10 + 1).join('asdf')));
            assert.equal(flatLongLen.toString(), (new Array(10 + 1).join('asdf')));
        });

        it('buffer from buffer', function() {
            var b1 = new B('asdf');
            var b2 = new B(b1);
            assert.equal(b1.toString('hex'), b2.toString('hex'));
        });

        it('fill', function() {
            var b = new B(10);
            b.fill(2);
            assert.equal(b.toString('hex'), '02020202020202020202');
        });

        it('copy() empty buffer with sourceEnd=0', function() {
            var source = new B([42]);
            var destination = new B([43]);
            source.copy(destination, 0, 0, 0);
            assert.equal(destination.readUInt8(0), 43);
        });

        it('base64 ignore whitespace', function() {
            var text = '\n   YW9ldQ==  ';
            var buf = new B(text, 'base64');
            assert.equal(buf.toString(), 'aoeu');
        });

        it('buffer.slice sets indexes', function() {
            assert.equal((new B('hallo')).slice(0, 5).toString(), 'hallo');
        });

        it('buffer.slice out of range', function() {
            assert.equal((new B('hallo')).slice(0, 10).toString(), 'hallo');
            assert.equal((new B('hallo')).slice(10, 2).toString(), '');
        });

        it('base64 strings without padding', function() {
            assert.equal((new B('YW9ldQ', 'base64').toString()), 'aoeu');
        });

        it('indexes from a string', function() {
            var buf = new B('abc');
            assert.equal(buf[0], 97);
            assert.equal(buf[1], 98);
            assert.equal(buf[2], 99);
        });

        it('indexes from an array', function() {
            var buf = new B([97, 98, 99]);
            assert.equal(buf[0], 97);
            assert.equal(buf[1], 98);
            assert.equal(buf[2], 99);
        });

        it('set then modify indexes from an array', function() {
            var buf = new B([97, 98, 99]);
            assert.equal(buf[2], 99);
            assert.equal(buf.toString(), 'abc');

            buf[2] += 10;
            assert.equal(buf[2], 109);
            assert.equal(buf.toString(), 'abm');
        });

        it('Buffer.isEncoding', function() {
            assert.equal(B.isEncoding('HEX'), true);
            assert.equal(B.isEncoding('hex'), true);
            assert.equal(B.isEncoding('bad'), false);
        });

    });
});